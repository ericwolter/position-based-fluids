#define TRANSPOSE (false)      // transpose the initial vector (faster memory access)

layout (local_size_x = _ITEMS) in;

layout (binding = 0, r32ui) uniform readonly  uimageBuffer imgInKeys;
layout (binding = 1, r32ui) uniform writeonly uimageBuffer imgHistogram;

layout (location = 0) uniform int pass;
layout (location = 1) uniform int nkeys;

shared uint loc_histo[_RADIX * _ITEMS];

// change of index for the transposition
int indexTranspose(uint i, uint nkeys)
{
    uint ip;
    if (TRANSPOSE)
    {
        uint k, l;
        k = i / (nkeys / _GROUPS / _ITEMS);
        l = i % (nkeys / _GROUPS / _ITEMS);
        ip = l * (_GROUPS * _ITEMS) + k;
    }
    else
    {
        ip = i;
    }
    return int(ip);
}

void main()                               
{
    uint it = gl_LocalInvocationID.x;
    uint ig = gl_GlobalInvocationID.x;

    uint gr = gl_WorkGroupID.x;

    uint groups = gl_NumWorkGroups.x;
    uint items = gl_WorkGroupSize.x;
    
    
    memoryBarrierShared( );
    
    // set the local histograms to zero
    for (int ir = 0; ir < _RADIX; ir++)
    {
        //d_Histograms[ir * groups * items + items * gr + it]=0;
        loc_histo[ir * items + it] = 0;
    }

    memoryBarrierShared( );


    // range of keys that are analyzed by the work item
    //int start= gr * nkeys/groups + it * nkeys/groups/items;
    uint start = ig * (nkeys / groups / items);
    uint size = nkeys / groups / items;

    uint key, shortkey;

    for (uint i = start; i < start + size; i++)
    {
        key = imageLoad(imgInKeys, indexTranspose(i, nkeys)).x;

        // extract the group of _BITS bits of the pass
        // the result is in the range 0.._RADIX-1
        shortkey = (( key >> (pass * _BITS)) & (_RADIX - 1));

        //d_Histograms[shortkey * groups * items + items * gr + it]++;
        loc_histo[shortkey *  items + it ]++;
    }

    memoryBarrierShared( );

    // copy the local histogram to the global one
    for (uint ir = 0; ir < _RADIX; ir++)
    {
        imageStore(imgHistogram, int(ir * groups * items + items * gr + it), ivec4(loc_histo[ir * items + it],0,0,0));
    }

    memoryBarrierShared( );
}
